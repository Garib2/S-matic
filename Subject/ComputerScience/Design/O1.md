---
layout: content
title: Intro
permalink: /info/CS/A1.md/
---
### 객체 지향 소프트웨어 설계의 어려움
- 객체 지향 소프트웨어 설계는 어렵고, 재사용 가능한 설계는 더욱 어려움.
- 적절한 객체를 찾아 클래스 단위로 분리하고, 클래스 인터페이스 및 상속 계층을 정의하며, 객체 간의 핵심 관계를 설정해야 함.
- 설계는 현재 문제에 맞게 구체적이어야 하며, 미래 문제도 해결할 수 있도록 일반적이어야 함.
- 재설계를 최소화하려면 반복적인 수정이 필요함.
  
### 경험 있는 설계자와 초보 설계자의 차이
- 경험 있는 설계자는 과거에 잘 작동한 해결책을 재사용하여 설계를 반복적으로 수정함.
- 초보자는 선택지가 많아 기존 비객체 지향 기법을 사용할 가능성이 있음.
  
### 디자인 패턴의 중요성
- **디자인 패턴**: 반복적인 설계 문제에 대한 검증된 해결책. 객체 지향 설계에서 유연하고 재사용 가능한 설계를 만드는 데 도움.
- 경험이 풍부한 설계자는 디자인 패턴을 활용하여 설계 문제를 빠르게 해결.
  
### 디자인 패턴의 사용 예시
- 소설가들이 자주 사용하는 플롯 패턴처럼, 객체 지향 설계에서도 '상태를 객체로 표현하기'와 같은 패턴을 따름.
  
### 디자인 패턴의 장점
- 디자인 패턴은 시스템 설계를 더 빠르고 효율적으로 만들고, 재사용성을 높이며, 문서화와 유지 관리에 도움이 됨.
  
### 책의 목적과 범위
- **목표**: 객체 지향 소프트웨어 설계 경험을 디자인 패턴으로 기록하여 재사용할 수 있게 함.
- **범위**: 이미 다양한 시스템에서 검증된 디자인만을 다루며, 동시성, 분산 프로그래밍 등은 포함하지 않음.
- **패턴 카탈로그**: 잘 알려지지 않은 패턴을 문서화하여 초보자가 쉽게 접근할 수 있도록 함.


## 1.1. What Is Daesign Pattern?
### 패턴의 네 가지 필수 요소

1. **패턴 이름**  
   - 디자인 문제, 해결책, 결과를 간단한 단어나 구로 설명할 수 있게 해주는 이름.
   - 패턴 이름을 통해 설계에 대한 높은 수준의 추상화를 할 수 있으며, 동료들과 문서화, 자기 생각을 쉽게 전달할 수 있음.

2. **문제**  
   - 패턴을 적용해야 하는 상황과 그 맥락을 설명.
   - 특정 디자인 문제나 불편한 설계 구조를 설명할 수 있음. 예를 들어, 알고리즘을 객체로 표현하는 방법이나 불완전한 디자인 구조가 이에 해당.

3. **해결책**  
   - 디자인을 구성하는 요소들, 이들의 관계, 책임, 협업을 설명.
   - 패턴은 특정 구현을 설명하지 않고, 일반적인 요소들이 문제를 해결하는 방식을 추상적으로 기술.

4. **결과**  
   - 패턴을 적용했을 때의 결과와 트레이드오프.
   - 설계 대안을 평가할 때 중요한 요소로, 공간과 시간 상의 트레이드오프, 언어와 구현 관련 문제를 포함할 수 있음.
   - 소프트웨어의 재사용성, 확장성, 이식성 등 시스템의 유연성에 미치는 영향도 포함.

### 관점의 차이가 패턴 해석에 미치는 영향

1. **패턴의 해석은 관점에 따라 달라짐**  
   - 한 사람에게는 패턴이 다른 사람에게는 기본 빌딩 블록이 될 수 있음.
   - 본 책에서는 특정 추상화 수준에서 패턴을 다룸.

2. **디자인 패턴의 정의**  
   - 본 책의 디자인 패턴은 **연결된 객체와 클래스**에 대한 설명으로, 일반적인 디자인 문제를 특정 문맥에서 해결하기 위해 맞춤화됨.
   - 디자인 패턴은 객체 지향 설계를 재사용 가능한 방식으로 만드는 데 유용한 공통된 디자인 구조의 핵심적인 측면을 식별하고 추상화함.
   - 패턴은 참여하는 클래스와 인스턴스, 그들의 역할과 협력 관계, 책임의 분배를 설명함.

3. **언어 선택의 중요성**  
   - **Smalltalk**와 **C++**에서 구현된 실용적인 솔루션을 기반으로 디자인 패턴을 설명.
   - 이 두 언어는 점점 더 인기를 끌고 있기 때문에 선택됨. 패턴은 이들 언어의 특징을 가정하고 구현됨.
   - 프로시저 언어(Pascal, C, Ada)나 더 동적 객체 지향 언어(CLOS, Dylan, Self)에 대한 패턴은 포함되지 않음.
   - 언어의 차이가 패턴을 구현하는 데 영향을 미침. 예를 들어, **CLOS**는 다중 메서드를 지원하여 `Visitor` 패턴이 필요 없을 수 있음.

4. **언어의 차이가 패턴 구현에 미치는 영향**  
   - **Smalltalk**과 **C++**은 각기 다른 방식으로 패턴을 표현할 수 있어 일부 패턴은 한 언어에서 더 쉽게 구현될 수 있음. (예: `Iterator` 패턴)
  

## 1.2 Design Patterns in Smalltalk MVC
### Model/View/Controller (MVC) 패턴

1. **MVC 개요**
   - **Model**: 애플리케이션 객체.
   - **View**: 화면에 대한 표현.
   - **Controller**: 사용자 입력에 대한 반응을 정의.
   - MVC는 이 세 가지 객체를 분리하여 **유연성과 재사용성**을 높임.

2. **Model과 View 분리**
   - MVC는 **subscribe/notify 프로토콜**을 사용하여 **Model**과 **View**를 분리.
   - 모델의 데이터가 변경되면, 모델은 이를 알리며 각 뷰는 업데이트됨.
   - 하나의 모델에 여러 뷰를 연결할 수 있고, 새로운 뷰를 추가할 때 모델을 재작성할 필요가 없음.

3. **일반적인 디자인 문제: Observer 패턴**
   - MVC는 **Observer** 패턴과 관련이 있음.
   - 이 패턴은 객체들이 서로 의존할 때, 한 객체의 변경이 여러 객체에 영향을 미치도록 하며, 변경된 객체는 다른 객체들에 대한 세부사항을 알지 않아도 됨.

4. **View의 중첩**
   - MVC는 **CompositeView** 클래스를 통해 중첩된 뷰를 지원.
   - 예를 들어, 버튼 뷰들이 포함된 복합 뷰를 만들 수 있음.
   - **Composite** 패턴과 관련이 있으며, 이는 개별 객체들을 그룹화하여 마치 하나의 객체처럼 취급할 수 있도록 함.

5. **Controller 객체로 사용자 입력 처리**
   - MVC는 **Controller** 객체를 통해 뷰가 사용자 입력에 어떻게 반응할지 캡슐화.
   - 컨트롤러 클래스 계층을 통해 기존 컨트롤러를 변형하여 새 컨트롤러를 쉽게 생성할 수 있음.

6. **Controller의 역할**
   - 뷰는 **Controller**의 하위 클래스를 인스턴스로 사용하여 특정 응답 전략을 구현.
   - 전략을 바꾸려면, 단순히 다른 종류의 컨트롤러로 교체하면 됨.
   - **런타임 중에 컨트롤러를 변경**하여 뷰의 사용자 입력에 대한 반응 방식을 바꿀 수 있음.
     - 예: 뷰를 비활성화하여 입력을 받지 않도록 하려면, 입력 이벤트를 무시하는 컨트롤러를 할당.

7. **Strategy 패턴**
   - 뷰와 컨트롤러의 관계는 **Strategy 패턴**의 예.
   - **Strategy**는 알고리즘을 나타내는 객체로, 알고리즘을 동적으로 또는 정적으로 교체하고자 할 때 유용함.
   - 알고리즘이 여러 변형을 가질 때나, 복잡한 데이터 구조를 캡슐화하고자 할 때 사용.

8. **MVC에서 사용된 다른 디자인 패턴**
   - **Factory Method**: 뷰의 기본 컨트롤러 클래스를 지정.
   - **Decorator**: 뷰에 스크롤 기능을 추가.
   - **Observer**, **Composite**, **Strategy** 패턴이 MVC의 주요 관계를 형성.

## 1.3 디자인 패턴 설명 방법

디자인 패턴을 설명하는 데 있어, 그래픽 표기법은 중요한 역할을 하지만 **불충분**합니다. 그래픽 표기법은 클래스와 객체 간의 관계를 캡슐화하는데 유용하지만, 디자인을 재사용하려면 그 디자인을 이끌어낸 **결정**, **대안**, 그리고 **트레이드오프**도 기록해야 합니다. **구체적인 예제**도 매우 중요합니다. 예제는 디자인이 실제로 어떻게 동작하는지 보여주기 때문입니다.

### 디자인 패턴 설명 템플릿

각 디자인 패턴은 일관된 형식을 따르며, 다음과 같은 섹션으로 나뉩니다.

1. **Pattern Name and Classification**
   - 패턴 이름은 패턴의 본질을 간결하게 전달합니다. 좋은 이름은 중요하며, 디자인 어휘의 일부가 됩니다.
   - 패턴 분류는 Section 1.5에서 소개한 분류 방식에 따라 다릅니다.

2. **Intent**
   - 패턴이 무엇을 하는지, 그 이유와 의도는 무엇인지, 해결하려는 구체적인 디자인 문제를 설명합니다.

3. **Also Known As**
   - 해당 패턴의 다른 이름이 있다면 함께 나열합니다.

4. **Motivation**
   - 디자인 문제와 그 문제를 해결하는 클래스 및 객체 구조를 보여주는 시나리오입니다.
   - 이 시나리오는 패턴의 추상적인 설명을 이해하는 데 도움이 됩니다.

5. **Applicability**
   - 패턴을 적용할 수 있는 상황과, 패턴이 해결할 수 있는 잘못된 디자인 사례를 설명합니다.
   - 이러한 상황을 어떻게 인식할 수 있는지 다룹니다.

6. **Structure**
   - 패턴 내 클래스의 구조를 **Object Modeling Technique (OMT)**[RBP+91] 기반으로 그래픽적으로 표현합니다.
   - 객체 간 요청 및 협업을 나타내는 **상호작용 다이어그램**을 사용하여 설명합니다.

7. **Participants**
   - 패턴에 참여하는 클래스 및 객체와 그들의 책임을 설명합니다.

8. **Collaborations**
   - 참가자들이 어떻게 협력하여 각자의 책임을 수행하는지에 대한 설명입니다.

9. **Consequences**
   - 패턴이 어떻게 목표를 지원하는지, 패턴을 사용함으로써 얻는 트레이드오프와 결과를 설명합니다.
   - 시스템 구조에서 독립적으로 변경할 수 있는 부분에 대해 설명합니다.

10. **Implementation**
    - 패턴을 구현할 때의 **문제점**, **팁**, 또는 **기술**을 다룹니다. 언어별로 고려할 사항도 포함될 수 있습니다.

11. **Sample Code**
    - 패턴을 C++ 또는 Smalltalk로 구현한 **코드 예제**를 제공합니다.

12. **Known Uses**
    - 실제 시스템에서 해당 패턴이 사용된 예시를 다룹니다. 다양한 도메인에서 두 가지 이상의 예시를 포함합니다.

13. **Related Patterns**
    - 이 패턴과 밀접하게 관련된 다른 디자인 패턴을 다룹니다.
    - 관련 패턴들과의 중요한 차이점과, 함께 사용할 수 있는 다른 패턴에 대해 설명합니다.

### 부록 및 참고자료
- **부록 A**: 사용된 용어들의 용어집.
- **부록 B**: 다양한 표기법에 대한 설명.
- **부록 C**: 코드 예제에서 사용된 기본 클래스들의 소스 코드.

## 1.4 디자인 패턴 카탈로그
### 디자인 패턴 카탈로그

다음은 책의 79페이지부터 시작하는 **디자인 패턴 카탈로그**에 포함된 23개의 디자인 패턴과 그 의도를 간략히 정리한 목록입니다. 각 패턴 이름 뒤에 있는 번호는 해당 패턴이 설명되는 페이지를 나타냅니다.

1. **Abstract Factory (87)**  
   - 관련이 있거나 의존적인 객체들의 계열을 생성할 수 있는 인터페이스를 제공하되, 구체적인 클래스를 지정하지 않음.

2. **Adapter (139)**  
   - 클래스의 인터페이스를 클라이언트가 기대하는 다른 인터페이스로 변환하여, 호환되지 않는 인터페이스를 가진 클래스들이 함께 작동할 수 있게 만듦.

3. **Bridge (151)**  
   - 추상화와 구현을 분리하여 두 가지가 독립적으로 변경될 수 있게 만듦.

4. **Builder (97)**  
   - 복잡한 객체의 구성을 표현과 분리하여 동일한 구성 프로세스로 다양한 표현을 생성할 수 있게 함.

5. **Chain of Responsibility (223)**  
   - 요청의 발신자와 수신자를 결합하지 않고 여러 객체가 요청을 처리할 수 있도록 하여, 요청을 객체들에 전달해가며 처리할 수 있게 함.

6. **Command (233)**  
   - 요청을 객체로 캡슐화하여 클라이언트에 다양한 요청을 파라미터화하고, 요청을 큐에 저장하거나 기록하며, 실행 취소 기능을 지원함.

7. **Composite (163)**  
   - 객체들을 트리 구조로 구성하여 부분-전체 계층을 나타내고, 클라이언트가 개별 객체와 객체의 조합을 일관되게 처리할 수 있도록 함.

8. **Decorator (175)**  
   - 객체에 동적으로 추가적인 책임을 부여하여 기능을 확장할 수 있도록 하는 유연한 방법을 제공.

9. **Facade (185)**  
   - 서브시스템 내의 여러 인터페이스에 대해 통합된 인터페이스를 제공하여 서브시스템을 쉽게 사용할 수 있도록 만듦.

10. **Factory Method (107)**  
    - 객체 생성을 위한 인터페이스를 정의하지만, 구체적인 클래스 인스턴스화는 서브클래스에서 결정하게 함.

11. **Flyweight (195)**  
    - 공유를 통해 많은 수의 세밀한 객체들을 효율적으로 지원함.

12. **Interpreter (243)**  
    - 언어의 문법을 나타내는 표현과 이를 해석하는 해석기를 정의하여 언어 문장을 해석함.

13. **Iterator (257)**  
    - 집합체 객체의 요소에 순차적으로 접근할 수 있는 방법을 제공하며, 그 내부 표현을 노출하지 않음.

14. **Mediator (273)**  
    - 객체들이 어떻게 상호작용하는지 캡슐화하는 객체를 정의하여, 객체들이 서로를 명시적으로 참조하지 않게 하며 상호작용을 독립적으로 변경할 수 있도록 함.

15. **Memento (283)**  
    - 캡슐화를 위반하지 않고 객체의 내부 상태를 캡처하고 외부화하여 나중에 해당 상태로 복원할 수 있도록 함.

16. **Observer (293)**  
    - 객체 간의 일대다 의존 관계를 정의하여, 하나의 객체 상태가 변경되면 모든 의존 객체들이 자동으로 알림을 받고 업데이트됨.

17. **Prototype (117)**  
    - 객체를 생성하는 방법으로 프로토타입 인스턴스를 사용하고, 이를 복사하여 새로운 객체를 생성함.

18. **Proxy (207)**  
    - 다른 객체의 대리인 또는 자리 표시자를 제공하여, 해당 객체에 대한 접근을 제어함.

19. **Singleton (127)**  
    - 클래스의 인스턴스를 하나만 존재하도록 보장하고, 이 인스턴스에 대한 글로벌 접근점을 제공함.

20. **State (305)**  
    - 객체가 내부 상태에 따라 행동을 변경할 수 있도록 하여, 객체가 마치 클래스가 변경된 것처럼 보이게 함.

21. **Strategy (315)**  
    - 알고리즘 계열을 정의하고, 각 알고리즘을 캡슐화하여 교환 가능하게 만듦. 클라이언트가 알고리즘을 독립적으로 변경할 수 있게 함.

22. **Template Method (325)**  
    - 알고리즘의 구조를 정의하고 일부 단계를 서브클래스에 위임하여 서브클래스가 알고리즘의 일부 단계를 재정의할 수 있게 함.

23. **Visitor (331)**  
    - 객체 구조의 요소들에 수행할 작업을 나타내는 연산을 정의하며, 요소들의 클래스를 변경하지 않고 새로운 연산을 정의할 수 있게 함.


## 1.5 디자인 패턴 분류

디자인 패턴은 그 규모와 추상화 수준이 다양합니다. 많은 디자인 패턴이 존재하기 때문에 이를 조직하는 방법이 필요합니다. 이 섹션에서는 디자인 패턴을 분류하여 관련 패턴들을 빠르게 학습하고, 새로운 패턴을 찾는 데 도움이 되도록 합니다. 디자인 패턴을 두 가지 기준에 따라 분류합니다.

#### 1. 목적 (Purpose)
패턴이 수행하는 작업에 따라 패턴을 **생성 패턴(Creational)**, **구조 패턴(Structural)**, **행동 패턴(Behavioral)**으로 나눕니다.

- **생성 패턴 (Creational)**: 객체 생성 과정과 관련된 패턴입니다.
- **구조 패턴 (Structural)**: 클래스나 객체의 구성을 다루는 패턴입니다.
- **행동 패턴 (Behavioral)**: 클래스나 객체 간의 상호작용과 책임 분배 방식을 정의하는 패턴입니다.

#### 2. 범위 (Scope)
패턴이 주로 **클래스(class)** 또는 **객체(object)**에 적용되는지에 따라 분류합니다.

- **클래스 패턴 (Class Patterns)**: 클래스 간의 관계를 다룹니다. 상속을 통해 고정된 관계를 설정하는 정적인 패턴입니다.
- **객체 패턴 (Object Patterns)**: 객체 간의 관계를 다루며, 런타임에서 변경될 수 있는 동적인 관계를 설정하는 패턴입니다.

#### 패턴의 특성

- **생성 클래스 패턴 (Creational Class Patterns)**: 객체 생성을 서브클래스에 위임합니다.
- **생성 객체 패턴 (Creational Object Patterns)**: 객체 생성을 다른 객체에 위임합니다.
- **구조 클래스 패턴 (Structural Class Patterns)**: 상속을 사용하여 클래스를 구성합니다.
- **구조 객체 패턴 (Structural Object Patterns)**: 객체를 구성하는 방법을 설명합니다.
- **행동 클래스 패턴 (Behavioral Class Patterns)**: 상속을 사용하여 알고리즘과 제어 흐름을 설명합니다.
- **행동 객체 패턴 (Behavioral Object Patterns)**: 여러 객체들이 협력하여 하나의 작업을 수행하는 방식을 설명합니다.

#### 패턴의 관계

- **조합적 관계**: Composite는 종종 Iterator나 Visitor와 함께 사용됩니다.
- **대체 관계**: Prototype은 Abstract Factory의 대체로 자주 사용됩니다.
- **유사한 설계**: Composite와 Decorator는 구조 다이어그램이 유사하지만 의도는 다릅니다.

#### 디자인 패턴 참조

각 패턴은 그 자체로 독립적인 특성을 가지고 있지만, 서로 어떻게 참조되는지에 따라 다른 방식으로 조직할 수 있습니다. 예를 들어, 각 패턴의 "관련 패턴" 섹션에서 다른 패턴과의 관계를 명시하고 있습니다. 이들 관계는 패턴의 목적과 적용 방식을 이해하는 데 도움이 됩니다.

#### 다양한 분류 방법

디자인 패턴을 분류하는 방법에는 여러 가지가 있으며, 각기 다른 관점에서 패턴을 분류하면 더 깊이 있는 통찰을 제공할 수 있습니다. 여러 가지 분류 방법을 통해 패턴이 무엇을 하고, 어떻게 비교되며, 언제 적용할지에 대한 이해를 높일 수 있습니다.

## 1.6 디자인 패턴이 디자인 문제를 해결하는 방법

디자인 패턴은 객체 지향 설계자가 매일 직면하는 여러 문제를 다양한 방식으로 해결합니다. 이 섹션에서는 몇 가지 주요 문제와 디자인 패턴이 어떻게 이를 해결하는지 설명합니다.

#### 1. 적절한 객체 찾기

객체 지향 프로그램은 객체로 구성됩니다. 객체는 데이터를 패키징하고 해당 데이터에서 작업을 수행하는 절차(메소드 또는 연산)를 포함합니다. 객체는 클라이언트로부터 요청(또는 메시지)을 받으면 연산을 수행합니다.

요청은 객체가 연산을 수행하도록 만드는 유일한 방법이며, 연산만이 객체의 내부 데이터를 변경하는 방법입니다. 이러한 제약 덕분에 객체의 내부 상태는 **캡슐화**되며, 외부에서 직접 접근할 수 없고 그 표현도 보이지 않습니다.

객체 지향 설계의 어려운 점은 시스템을 객체로 분해하는 것입니다. 이 작업은 여러 요인—캡슐화, 세분화, 의존성, 유연성, 성능, 진화 가능성, 재사용성 등—이 모두 영향을 미치기 때문에 어렵습니다. 이러한 요인들이 서로 상충할 때가 많습니다.

#### 2. 객체 지향 설계 방법론

객체 지향 설계 방법론은 여러 접근 방식을 제시합니다. 예를 들어, 문제를 정의하고 명사와 동사를 구분하여 해당하는 클래스와 연산을 생성할 수 있습니다. 또는 시스템 내의 협업과 책임에 집중할 수도 있습니다. 또는 현실 세계를 모델링하여 분석 중에 발견된 객체를 설계로 변환할 수 있습니다. 어떤 접근 방식이 가장 좋은지는 항상 논란의 여지가 있습니다.

#### 3. 분석 모델과 설계 모델

많은 객체들이 분석 모델에서 유래하지만, 객체 지향 설계에서는 종종 현실 세계에 대응하는 클래스가 없는 경우가 많습니다. 일부 클래스는 배열 같은 저수준 클래스일 수 있고, 다른 클래스는 매우 높은 수준의 것일 수 있습니다. 예를 들어, **Composite** 패턴은 물리적인 대응 객체 없이 객체들을 일관되게 처리할 수 있는 추상화를 도입합니다.

현실 세계를 엄격하게 모델링하면 오늘날의 현실을 반영하는 시스템이 만들어지지만, 내일의 현실을 반영하지 못할 수 있습니다. 설계 중에 등장하는 추상화는 설계를 유연하게 만드는 데 핵심적인 역할을 합니다. 디자인 패턴은 덜 직관적인 추상화와 이를 캡슐화할 수 있는 객체들을 식별하는 데 도움을 줍니다.

#### 4. 유연하고 재사용 가능한 설계를 위한 객체

예를 들어, 프로세스나 알고리즘을 나타내는 객체는 자연계에서는 발생하지 않지만 유연한 설계에 있어서 중요한 역할을 합니다. **Strategy** 패턴은 교환 가능한 알고리즘 패밀리를 구현하는 방법을 설명합니다. **State** 패턴은 엔티티의 각 상태를 객체로 나타냅니다. 이러한 객체들은 분석이나 초기 설계 단계에서는 잘 발견되지 않지만, 설계를 더 유연하고 재사용 가능하게 만들면서 나중에 발견됩니다.


### 객체의 세분화 결정하기

객체는 크기와 수에 있어서 매우 다양할 수 있습니다. 객체는 하드웨어부터 전체 애플리케이션까지 모든 것을 나타낼 수 있습니다. 그러면 무엇을 객체로 정의할지 어떻게 결정할까요?

디자인 패턴은 이 문제도 다룹니다. 예를 들어:

- **Facade (185)** 패턴은 전체 서브시스템을 객체로 표현하는 방법을 설명합니다. 복잡한 시스템을 하나의 통합된 인터페이스로 캡슐화하여 사용자가 쉽게 접근할 수 있게 합니다.
- **Flyweight (195)** 패턴은 세밀한 수준에서 많은 객체를 효율적으로 지원하는 방법을 설명합니다. 객체의 공유를 통해 메모리 사용을 최소화하면서도 많은 객체를 생성할 수 있도록 합니다.

또한, 다른 디자인 패턴들은 객체를 작은 객체들로 분해하는 구체적인 방법을 제공합니다:

- **Abstract Factory (87)**와 **Builder (97)** 패턴은 객체의 주요 책임이 다른 객체들을 생성하는 것인 경우에 사용됩니다.
- **Visitor (331)**와 **Command (233)** 패턴은 객체나 객체 그룹에 대한 요청을 구현하는 것을 주요 책임으로 합니다. 즉, 해당 객체들은 요청을 처리하는 역할을 수행합니다.

- ### 객체 인터페이스 정의하기

객체에서 선언된 각 작업은 작업의 이름, 매개변수로 받는 객체들, 그리고 작업의 반환 값을 정의합니다. 이를 작업의 **서명**(signature)이라고 합니다. 객체가 정의한 모든 서명의 집합은 객체의 **인터페이스**(interface)라고 불립니다. 객체의 인터페이스는 해당 객체에 보낼 수 있는 모든 요청을 특성화합니다. 인터페이스에 정의된 서명에 맞는 요청은 모두 해당 객체에 전송할 수 있습니다.

#### 타입과 서브타입

- **타입**은 특정 인터페이스를 나타내는 이름입니다. 예를 들어, "Window"라는 인터페이스에 정의된 모든 요청을 받는 객체는 "Window" 타입을 가집니다.
- 하나의 객체는 여러 타입을 가질 수 있으며, 매우 다른 객체들이 동일한 타입을 공유할 수 있습니다.
- 객체의 일부 인터페이스는 하나의 타입으로 정의될 수 있고, 다른 부분은 다른 타입으로 정의될 수 있습니다.
- 한 타입이 다른 타입의 서브타입이 되려면, 그 타입의 인터페이스가 슈퍼타입의 인터페이스를 포함해야 합니다. 보통 **서브타입**은 **슈퍼타입**의 인터페이스를 **상속**한다고 말합니다.

#### 인터페이스의 중요성

- 객체는 **인터페이스를 통해서만** 인식되고 상호작용됩니다. 객체의 구현에 대해 알 수 없으며, 그 객체에게 작업을 요청할 수 있는 방법도 인터페이스를 통해서만 가능합니다.
- 객체의 인터페이스는 객체의 구현에 대해 아무런 정보를 제공하지 않습니다. 즉, 서로 전혀 다른 구현을 가진 객체들이 동일한 인터페이스를 가질 수 있습니다.

#### 동적 바인딩과 다형성

- 요청을 객체에 보내면, 어떤 작업이 수행될지는 요청과 수신 객체에 따라 달라집니다. 동일한 요청을 지원하는 서로 다른 객체들이 그 요청을 처리하는 방법은 다를 수 있습니다.
- **동적 바인딩**(dynamic binding)은 요청과 객체의 연관이 실행 시간에 결정된다는 것을 의미합니다. 이로 인해 프로그램은 특정 인터페이스를 가진 객체에 대해 요청을 할 수 있으며, 실행 시간에 올바른 객체가 해당 요청을 처리합니다.
- **다형성**(polymorphism)은 동일한 인터페이스를 가진 객체들이 서로 교체 가능함을 의미하며, 객체 지향 시스템에서 핵심 개념입니다. 이를 통해 클라이언트 객체는 다른 객체에 대해 적은 가정을 하고, 객체들 간의 관계를 실행 시간에 동적으로 변경할 수 있습니다.

#### 디자인 패턴과 인터페이스 정의

- 디자인 패턴은 인터페이스를 정의하는 데 도움을 주며, 중요한 요소들과 그 인터페이스를 통해 전달되는 데이터의 종류를 식별합니다. 패턴은 또한 인터페이스에 무엇을 포함하지 말아야 하는지에 대해서도 제시할 수 있습니다.
- 예를 들어, **Memento (283)** 패턴은 객체의 내부 상태를 캡슐화하고 저장하여 나중에 해당 상태로 객체를 복원할 수 있도록 정의합니다. 이 패턴은 Memento 객체가 두 가지 인터페이스를 정의해야 한다고 요구합니다: 하나는 클라이언트가 Memento를 보유하고 복사할 수 있는 제한된 인터페이스이고, 다른 하나는 원래 객체만 사용할 수 있는 특권 인터페이스입니다.

#### 인터페이스 간의 관계

디자인 패턴은 인터페이스 간의 관계를 정의하기도 합니다. 예를 들어:

- **Decorator (175)**와 **Proxy (207)** 패턴은 데코레이터 및 프록시 객체의 인터페이스가 장식된 객체 및 프록시된 객체와 동일해야 한다고 요구합니다.
- **Visitor (331)** 패턴은 방문자가 방문할 수 있는 객체들의 모든 클래스가 **Visitor** 인터페이스에 반영되어야 한다고 명시합니다.

### 객체 구현 정의하기

지금까지 객체를 정의하는 방법에 대해서는 크게 다루지 않았습니다. 객체의 구현은 **클래스**에 의해 정의됩니다. 클래스는 객체의 내부 데이터와 표현 방식을 지정하고, 객체가 수행할 수 있는 작업을 정의합니다.

#### 클래스 정의

- **클래스**는 보통 직사각형 모양으로 나타내며, 클래스 이름은 굵게 표시됩니다. 클래스의 작업은 클래스 이름 아래에 일반 텍스트로 나타납니다. 클래스가 정의하는 데이터는 작업 아래에 나옵니다.
- 반환 타입과 인스턴스 변수 타입은 선택 사항이며, 정적 타입 언어를 전제로 하지 않습니다.

#### 객체 생성 및 인스턴스화

- 객체는 클래스를 **인스턴스화**(instantiation)함으로써 생성됩니다. 인스턴스화된 객체는 해당 클래스의 **인스턴스**라고 합니다. 클래스를 인스턴스화하는 과정은 객체의 내부 데이터(인스턴스 변수로 구성된)를 저장할 공간을 할당하고, 이 데이터에 대해 작업을 연관시킵니다.
- 여러 개의 객체를 만들기 위해 동일한 클래스를 인스턴스화할 수 있습니다.

#### 클래스 관계 및 상속

- 클래스가 다른 클래스를 인스턴스화하는 경우, 이를 나타내기 위해 **대시 화살표**가 사용되며, 화살표는 인스턴스화된 객체의 클래스를 가리킵니다.
- **상속**을 통해 새로운 클래스를 정의할 수 있습니다. 서브클래스는 부모 클래스의 데이터와 작업을 포함하여 정의됩니다. 서브클래스의 객체는 서브클래스와 부모 클래스가 정의한 모든 데이터를 포함하고, 이들이 정의한 모든 작업을 수행할 수 있습니다.
- **상속 관계**는 세로선과 삼각형으로 표시됩니다.

#### 추상 클래스와 구체 클래스

- **추상 클래스**는 주로 자식 클래스들의 공통 인터페이스를 정의하는 데 목적이 있습니다. 추상 클래스는 자식 클래스에서 구현할 작업들을 미리 정의해 두며, 추상 클래스 자체로는 인스턴스를 만들 수 없습니다. 추상 클래스에서 정의되었지만 구현되지 않은 작업은 **추상 작업**(abstract operation)이라고 합니다.
- **구체 클래스**(Concrete Class)는 추상 클래스와 달리 실제 구현이 완료된 클래스를 의미하며, 인스턴스를 만들 수 있습니다.

#### 작업 재정의 및 클래스 세분화

- 서브클래스는 부모 클래스에서 정의된 작업을 **재정의**(override)할 수 있습니다. 작업 재정의는 서브클래스가 요청을 처리하는 방식을 부모 클래스 대신 처리할 수 있게 합니다.
- 클래스 상속은 다른 클래스를 확장하여 클래스를 정의할 수 있게 해주며, 이를 통해 관련된 기능을 가진 객체들 간의 계층을 쉽게 정의할 수 있습니다.

#### 추상 클래스와 구체 클래스의 구분

- 추상 클래스는 기울임꼴로 표시되어 구체 클래스와 구별됩니다. 기울임꼴은 **추상 작업**에도 사용됩니다.
- 다이어그램에 작업 구현을 위한 **유사 코드**(pseudocode)가 포함될 수 있으며, 이 코드가 해당 작업을 구현하는 **대기선 박스**에 연결됩니다.

#### 믹스인 클래스

- **믹스인 클래스**(mixin class)는 다른 클래스에 선택적 인터페이스나 기능을 제공하기 위한 클래스로, 인스턴스화될 목적이 아닙니다. 믹스인 클래스는 **다중 상속**을 요구합니다.

