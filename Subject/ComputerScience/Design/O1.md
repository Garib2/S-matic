---
layout: content
title: Intro
permalink: /info/CS/A1.md/
---
### 객체 지향 소프트웨어 설계의 어려움
- 객체 지향 소프트웨어 설계는 어렵고, 재사용 가능한 설계는 더욱 어려움.
- 적절한 객체를 찾아 클래스 단위로 분리하고, 클래스 인터페이스 및 상속 계층을 정의하며, 객체 간의 핵심 관계를 설정해야 함.
- 설계는 현재 문제에 맞게 구체적이어야 하며, 미래 문제도 해결할 수 있도록 일반적이어야 함.
- 재설계를 최소화하려면 반복적인 수정이 필요함.
  
### 경험 있는 설계자와 초보 설계자의 차이
- 경험 있는 설계자는 과거에 잘 작동한 해결책을 재사용하여 설계를 반복적으로 수정함.
- 초보자는 선택지가 많아 기존 비객체 지향 기법을 사용할 가능성이 있음.
  
### 디자인 패턴의 중요성
- **디자인 패턴**: 반복적인 설계 문제에 대한 검증된 해결책. 객체 지향 설계에서 유연하고 재사용 가능한 설계를 만드는 데 도움.
- 경험이 풍부한 설계자는 디자인 패턴을 활용하여 설계 문제를 빠르게 해결.
  
### 디자인 패턴의 사용 예시
- 소설가들이 자주 사용하는 플롯 패턴처럼, 객체 지향 설계에서도 '상태를 객체로 표현하기'와 같은 패턴을 따름.
  
### 디자인 패턴의 장점
- 디자인 패턴은 시스템 설계를 더 빠르고 효율적으로 만들고, 재사용성을 높이며, 문서화와 유지 관리에 도움이 됨.
  
### 책의 목적과 범위
- **목표**: 객체 지향 소프트웨어 설계 경험을 디자인 패턴으로 기록하여 재사용할 수 있게 함.
- **범위**: 이미 다양한 시스템에서 검증된 디자인만을 다루며, 동시성, 분산 프로그래밍 등은 포함하지 않음.
- **패턴 카탈로그**: 잘 알려지지 않은 패턴을 문서화하여 초보자가 쉽게 접근할 수 있도록 함.


## 1.1. What Is Daesign Pattern?
### 패턴의 네 가지 필수 요소

1. **패턴 이름**  
   - 디자인 문제, 해결책, 결과를 간단한 단어나 구로 설명할 수 있게 해주는 이름.
   - 패턴 이름을 통해 설계에 대한 높은 수준의 추상화를 할 수 있으며, 동료들과 문서화, 자기 생각을 쉽게 전달할 수 있음.

2. **문제**  
   - 패턴을 적용해야 하는 상황과 그 맥락을 설명.
   - 특정 디자인 문제나 불편한 설계 구조를 설명할 수 있음. 예를 들어, 알고리즘을 객체로 표현하는 방법이나 불완전한 디자인 구조가 이에 해당.

3. **해결책**  
   - 디자인을 구성하는 요소들, 이들의 관계, 책임, 협업을 설명.
   - 패턴은 특정 구현을 설명하지 않고, 일반적인 요소들이 문제를 해결하는 방식을 추상적으로 기술.

4. **결과**  
   - 패턴을 적용했을 때의 결과와 트레이드오프.
   - 설계 대안을 평가할 때 중요한 요소로, 공간과 시간 상의 트레이드오프, 언어와 구현 관련 문제를 포함할 수 있음.
   - 소프트웨어의 재사용성, 확장성, 이식성 등 시스템의 유연성에 미치는 영향도 포함.

### 관점의 차이가 패턴 해석에 미치는 영향

1. **패턴의 해석은 관점에 따라 달라짐**  
   - 한 사람에게는 패턴이 다른 사람에게는 기본 빌딩 블록이 될 수 있음.
   - 본 책에서는 특정 추상화 수준에서 패턴을 다룸.

2. **디자인 패턴의 정의**  
   - 본 책의 디자인 패턴은 **연결된 객체와 클래스**에 대한 설명으로, 일반적인 디자인 문제를 특정 문맥에서 해결하기 위해 맞춤화됨.
   - 디자인 패턴은 객체 지향 설계를 재사용 가능한 방식으로 만드는 데 유용한 공통된 디자인 구조의 핵심적인 측면을 식별하고 추상화함.
   - 패턴은 참여하는 클래스와 인스턴스, 그들의 역할과 협력 관계, 책임의 분배를 설명함.

3. **언어 선택의 중요성**  
   - **Smalltalk**와 **C++**에서 구현된 실용적인 솔루션을 기반으로 디자인 패턴을 설명.
   - 이 두 언어는 점점 더 인기를 끌고 있기 때문에 선택됨. 패턴은 이들 언어의 특징을 가정하고 구현됨.
   - 프로시저 언어(Pascal, C, Ada)나 더 동적 객체 지향 언어(CLOS, Dylan, Self)에 대한 패턴은 포함되지 않음.
   - 언어의 차이가 패턴을 구현하는 데 영향을 미침. 예를 들어, **CLOS**는 다중 메서드를 지원하여 `Visitor` 패턴이 필요 없을 수 있음.

4. **언어의 차이가 패턴 구현에 미치는 영향**  
   - **Smalltalk**과 **C++**은 각기 다른 방식으로 패턴을 표현할 수 있어 일부 패턴은 한 언어에서 더 쉽게 구현될 수 있음. (예: `Iterator` 패턴)
  

## 1.2 Design Patterns in Smalltalk MVC
### Model/View/Controller (MVC) 패턴

1. **MVC 개요**
   - **Model**: 애플리케이션 객체.
   - **View**: 화면에 대한 표현.
   - **Controller**: 사용자 입력에 대한 반응을 정의.
   - MVC는 이 세 가지 객체를 분리하여 **유연성과 재사용성**을 높임.

2. **Model과 View 분리**
   - MVC는 **subscribe/notify 프로토콜**을 사용하여 **Model**과 **View**를 분리.
   - 모델의 데이터가 변경되면, 모델은 이를 알리며 각 뷰는 업데이트됨.
   - 하나의 모델에 여러 뷰를 연결할 수 있고, 새로운 뷰를 추가할 때 모델을 재작성할 필요가 없음.

3. **일반적인 디자인 문제: Observer 패턴**
   - MVC는 **Observer** 패턴과 관련이 있음.
   - 이 패턴은 객체들이 서로 의존할 때, 한 객체의 변경이 여러 객체에 영향을 미치도록 하며, 변경된 객체는 다른 객체들에 대한 세부사항을 알지 않아도 됨.

4. **View의 중첩**
   - MVC는 **CompositeView** 클래스를 통해 중첩된 뷰를 지원.
   - 예를 들어, 버튼 뷰들이 포함된 복합 뷰를 만들 수 있음.
   - **Composite** 패턴과 관련이 있으며, 이는 개별 객체들을 그룹화하여 마치 하나의 객체처럼 취급할 수 있도록 함.

5. **Controller 객체로 사용자 입력 처리**
   - MVC는 **Controller** 객체를 통해 뷰가 사용자 입력에 어떻게 반응할지 캡슐화.
   - 컨트롤러 클래스 계층을 통해 기존 컨트롤러를 변형하여 새 컨트롤러를 쉽게 생성할 수 있음.

6. **Controller의 역할**
   - 뷰는 **Controller**의 하위 클래스를 인스턴스로 사용하여 특정 응답 전략을 구현.
   - 전략을 바꾸려면, 단순히 다른 종류의 컨트롤러로 교체하면 됨.
   - **런타임 중에 컨트롤러를 변경**하여 뷰의 사용자 입력에 대한 반응 방식을 바꿀 수 있음.
     - 예: 뷰를 비활성화하여 입력을 받지 않도록 하려면, 입력 이벤트를 무시하는 컨트롤러를 할당.

7. **Strategy 패턴**
   - 뷰와 컨트롤러의 관계는 **Strategy 패턴**의 예.
   - **Strategy**는 알고리즘을 나타내는 객체로, 알고리즘을 동적으로 또는 정적으로 교체하고자 할 때 유용함.
   - 알고리즘이 여러 변형을 가질 때나, 복잡한 데이터 구조를 캡슐화하고자 할 때 사용.

8. **MVC에서 사용된 다른 디자인 패턴**
   - **Factory Method**: 뷰의 기본 컨트롤러 클래스를 지정.
   - **Decorator**: 뷰에 스크롤 기능을 추가.
   - **Observer**, **Composite**, **Strategy** 패턴이 MVC의 주요 관계를 형성.

## 1.3 디자인 패턴 설명 방법

디자인 패턴을 설명하는 데 있어, 그래픽 표기법은 중요한 역할을 하지만 **불충분**합니다. 그래픽 표기법은 클래스와 객체 간의 관계를 캡슐화하는데 유용하지만, 디자인을 재사용하려면 그 디자인을 이끌어낸 **결정**, **대안**, 그리고 **트레이드오프**도 기록해야 합니다. **구체적인 예제**도 매우 중요합니다. 예제는 디자인이 실제로 어떻게 동작하는지 보여주기 때문입니다.

### 디자인 패턴 설명 템플릿

각 디자인 패턴은 일관된 형식을 따르며, 다음과 같은 섹션으로 나뉩니다.

1. **Pattern Name and Classification**
   - 패턴 이름은 패턴의 본질을 간결하게 전달합니다. 좋은 이름은 중요하며, 디자인 어휘의 일부가 됩니다.
   - 패턴 분류는 Section 1.5에서 소개한 분류 방식에 따라 다릅니다.

2. **Intent**
   - 패턴이 무엇을 하는지, 그 이유와 의도는 무엇인지, 해결하려는 구체적인 디자인 문제를 설명합니다.

3. **Also Known As**
   - 해당 패턴의 다른 이름이 있다면 함께 나열합니다.

4. **Motivation**
   - 디자인 문제와 그 문제를 해결하는 클래스 및 객체 구조를 보여주는 시나리오입니다.
   - 이 시나리오는 패턴의 추상적인 설명을 이해하는 데 도움이 됩니다.

5. **Applicability**
   - 패턴을 적용할 수 있는 상황과, 패턴이 해결할 수 있는 잘못된 디자인 사례를 설명합니다.
   - 이러한 상황을 어떻게 인식할 수 있는지 다룹니다.

6. **Structure**
   - 패턴 내 클래스의 구조를 **Object Modeling Technique (OMT)**[RBP+91] 기반으로 그래픽적으로 표현합니다.
   - 객체 간 요청 및 협업을 나타내는 **상호작용 다이어그램**을 사용하여 설명합니다.

7. **Participants**
   - 패턴에 참여하는 클래스 및 객체와 그들의 책임을 설명합니다.

8. **Collaborations**
   - 참가자들이 어떻게 협력하여 각자의 책임을 수행하는지에 대한 설명입니다.

9. **Consequences**
   - 패턴이 어떻게 목표를 지원하는지, 패턴을 사용함으로써 얻는 트레이드오프와 결과를 설명합니다.
   - 시스템 구조에서 독립적으로 변경할 수 있는 부분에 대해 설명합니다.

10. **Implementation**
    - 패턴을 구현할 때의 **문제점**, **팁**, 또는 **기술**을 다룹니다. 언어별로 고려할 사항도 포함될 수 있습니다.

11. **Sample Code**
    - 패턴을 C++ 또는 Smalltalk로 구현한 **코드 예제**를 제공합니다.

12. **Known Uses**
    - 실제 시스템에서 해당 패턴이 사용된 예시를 다룹니다. 다양한 도메인에서 두 가지 이상의 예시를 포함합니다.

13. **Related Patterns**
    - 이 패턴과 밀접하게 관련된 다른 디자인 패턴을 다룹니다.
    - 관련 패턴들과의 중요한 차이점과, 함께 사용할 수 있는 다른 패턴에 대해 설명합니다.

### 부록 및 참고자료
- **부록 A**: 사용된 용어들의 용어집.
- **부록 B**: 다양한 표기법에 대한 설명.
- **부록 C**: 코드 예제에서 사용된 기본 클래스들의 소스 코드.

## 1.4 디자인 패턴 카탈로그
### 디자인 패턴 카탈로그

다음은 책의 79페이지부터 시작하는 **디자인 패턴 카탈로그**에 포함된 23개의 디자인 패턴과 그 의도를 간략히 정리한 목록입니다. 각 패턴 이름 뒤에 있는 번호는 해당 패턴이 설명되는 페이지를 나타냅니다.

1. **Abstract Factory (87)**  
   - 관련이 있거나 의존적인 객체들의 계열을 생성할 수 있는 인터페이스를 제공하되, 구체적인 클래스를 지정하지 않음.

2. **Adapter (139)**  
   - 클래스의 인터페이스를 클라이언트가 기대하는 다른 인터페이스로 변환하여, 호환되지 않는 인터페이스를 가진 클래스들이 함께 작동할 수 있게 만듦.

3. **Bridge (151)**  
   - 추상화와 구현을 분리하여 두 가지가 독립적으로 변경될 수 있게 만듦.

4. **Builder (97)**  
   - 복잡한 객체의 구성을 표현과 분리하여 동일한 구성 프로세스로 다양한 표현을 생성할 수 있게 함.

5. **Chain of Responsibility (223)**  
   - 요청의 발신자와 수신자를 결합하지 않고 여러 객체가 요청을 처리할 수 있도록 하여, 요청을 객체들에 전달해가며 처리할 수 있게 함.

6. **Command (233)**  
   - 요청을 객체로 캡슐화하여 클라이언트에 다양한 요청을 파라미터화하고, 요청을 큐에 저장하거나 기록하며, 실행 취소 기능을 지원함.

7. **Composite (163)**  
   - 객체들을 트리 구조로 구성하여 부분-전체 계층을 나타내고, 클라이언트가 개별 객체와 객체의 조합을 일관되게 처리할 수 있도록 함.

8. **Decorator (175)**  
   - 객체에 동적으로 추가적인 책임을 부여하여 기능을 확장할 수 있도록 하는 유연한 방법을 제공.

9. **Facade (185)**  
   - 서브시스템 내의 여러 인터페이스에 대해 통합된 인터페이스를 제공하여 서브시스템을 쉽게 사용할 수 있도록 만듦.

10. **Factory Method (107)**  
    - 객체 생성을 위한 인터페이스를 정의하지만, 구체적인 클래스 인스턴스화는 서브클래스에서 결정하게 함.

11. **Flyweight (195)**  
    - 공유를 통해 많은 수의 세밀한 객체들을 효율적으로 지원함.

12. **Interpreter (243)**  
    - 언어의 문법을 나타내는 표현과 이를 해석하는 해석기를 정의하여 언어 문장을 해석함.

13. **Iterator (257)**  
    - 집합체 객체의 요소에 순차적으로 접근할 수 있는 방법을 제공하며, 그 내부 표현을 노출하지 않음.

14. **Mediator (273)**  
    - 객체들이 어떻게 상호작용하는지 캡슐화하는 객체를 정의하여, 객체들이 서로를 명시적으로 참조하지 않게 하며 상호작용을 독립적으로 변경할 수 있도록 함.

15. **Memento (283)**  
    - 캡슐화를 위반하지 않고 객체의 내부 상태를 캡처하고 외부화하여 나중에 해당 상태로 복원할 수 있도록 함.

16. **Observer (293)**  
    - 객체 간의 일대다 의존 관계를 정의하여, 하나의 객체 상태가 변경되면 모든 의존 객체들이 자동으로 알림을 받고 업데이트됨.

17. **Prototype (117)**  
    - 객체를 생성하는 방법으로 프로토타입 인스턴스를 사용하고, 이를 복사하여 새로운 객체를 생성함.

18. **Proxy (207)**  
    - 다른 객체의 대리인 또는 자리 표시자를 제공하여, 해당 객체에 대한 접근을 제어함.

19. **Singleton (127)**  
    - 클래스의 인스턴스를 하나만 존재하도록 보장하고, 이 인스턴스에 대한 글로벌 접근점을 제공함.

20. **State (305)**  
    - 객체가 내부 상태에 따라 행동을 변경할 수 있도록 하여, 객체가 마치 클래스가 변경된 것처럼 보이게 함.

21. **Strategy (315)**  
    - 알고리즘 계열을 정의하고, 각 알고리즘을 캡슐화하여 교환 가능하게 만듦. 클라이언트가 알고리즘을 독립적으로 변경할 수 있게 함.

22. **Template Method (325)**  
    - 알고리즘의 구조를 정의하고 일부 단계를 서브클래스에 위임하여 서브클래스가 알고리즘의 일부 단계를 재정의할 수 있게 함.

23. **Visitor (331)**  
    - 객체 구조의 요소들에 수행할 작업을 나타내는 연산을 정의하며, 요소들의 클래스를 변경하지 않고 새로운 연산을 정의할 수 있게 함.


## 1.5 디자인 패턴 분류

디자인 패턴은 그 규모와 추상화 수준이 다양합니다. 많은 디자인 패턴이 존재하기 때문에 이를 조직하는 방법이 필요합니다. 이 섹션에서는 디자인 패턴을 분류하여 관련 패턴들을 빠르게 학습하고, 새로운 패턴을 찾는 데 도움이 되도록 합니다. 디자인 패턴을 두 가지 기준에 따라 분류합니다.

#### 1. 목적 (Purpose)
패턴이 수행하는 작업에 따라 패턴을 **생성 패턴(Creational)**, **구조 패턴(Structural)**, **행동 패턴(Behavioral)**으로 나눕니다.

- **생성 패턴 (Creational)**: 객체 생성 과정과 관련된 패턴입니다.
- **구조 패턴 (Structural)**: 클래스나 객체의 구성을 다루는 패턴입니다.
- **행동 패턴 (Behavioral)**: 클래스나 객체 간의 상호작용과 책임 분배 방식을 정의하는 패턴입니다.

#### 2. 범위 (Scope)
패턴이 주로 **클래스(class)** 또는 **객체(object)**에 적용되는지에 따라 분류합니다.

- **클래스 패턴 (Class Patterns)**: 클래스 간의 관계를 다룹니다. 상속을 통해 고정된 관계를 설정하는 정적인 패턴입니다.
- **객체 패턴 (Object Patterns)**: 객체 간의 관계를 다루며, 런타임에서 변경될 수 있는 동적인 관계를 설정하는 패턴입니다.

#### 패턴의 특성

- **생성 클래스 패턴 (Creational Class Patterns)**: 객체 생성을 서브클래스에 위임합니다.
- **생성 객체 패턴 (Creational Object Patterns)**: 객체 생성을 다른 객체에 위임합니다.
- **구조 클래스 패턴 (Structural Class Patterns)**: 상속을 사용하여 클래스를 구성합니다.
- **구조 객체 패턴 (Structural Object Patterns)**: 객체를 구성하는 방법을 설명합니다.
- **행동 클래스 패턴 (Behavioral Class Patterns)**: 상속을 사용하여 알고리즘과 제어 흐름을 설명합니다.
- **행동 객체 패턴 (Behavioral Object Patterns)**: 여러 객체들이 협력하여 하나의 작업을 수행하는 방식을 설명합니다.

#### 패턴의 관계

- **조합적 관계**: Composite는 종종 Iterator나 Visitor와 함께 사용됩니다.
- **대체 관계**: Prototype은 Abstract Factory의 대체로 자주 사용됩니다.
- **유사한 설계**: Composite와 Decorator는 구조 다이어그램이 유사하지만 의도는 다릅니다.

#### 디자인 패턴 참조

각 패턴은 그 자체로 독립적인 특성을 가지고 있지만, 서로 어떻게 참조되는지에 따라 다른 방식으로 조직할 수 있습니다. 예를 들어, 각 패턴의 "관련 패턴" 섹션에서 다른 패턴과의 관계를 명시하고 있습니다. 이들 관계는 패턴의 목적과 적용 방식을 이해하는 데 도움이 됩니다.

#### 다양한 분류 방법

디자인 패턴을 분류하는 방법에는 여러 가지가 있으며, 각기 다른 관점에서 패턴을 분류하면 더 깊이 있는 통찰을 제공할 수 있습니다. 여러 가지 분류 방법을 통해 패턴이 무엇을 하고, 어떻게 비교되며, 언제 적용할지에 대한 이해를 높일 수 있습니다.

## 1.6 디자인 패턴이 디자인 문제를 해결하는 방법

디자인 패턴은 객체 지향 설계자가 매일 직면하는 여러 문제를 다양한 방식으로 해결합니다. 이 섹션에서는 몇 가지 주요 문제와 디자인 패턴이 어떻게 이를 해결하는지 설명합니다.

#### 1. 적절한 객체 찾기

객체 지향 프로그램은 객체로 구성됩니다. 객체는 데이터를 패키징하고 해당 데이터에서 작업을 수행하는 절차(메소드 또는 연산)를 포함합니다. 객체는 클라이언트로부터 요청(또는 메시지)을 받으면 연산을 수행합니다.

요청은 객체가 연산을 수행하도록 만드는 유일한 방법이며, 연산만이 객체의 내부 데이터를 변경하는 방법입니다. 이러한 제약 덕분에 객체의 내부 상태는 **캡슐화**되며, 외부에서 직접 접근할 수 없고 그 표현도 보이지 않습니다.

객체 지향 설계의 어려운 점은 시스템을 객체로 분해하는 것입니다. 이 작업은 여러 요인—캡슐화, 세분화, 의존성, 유연성, 성능, 진화 가능성, 재사용성 등—이 모두 영향을 미치기 때문에 어렵습니다. 이러한 요인들이 서로 상충할 때가 많습니다.

#### 객체 지향 설계 방법론

객체 지향 설계 방법론은 여러 접근 방식을 제시합니다. 예를 들어, 문제를 정의하고 명사와 동사를 구분하여 해당하는 클래스와 연산을 생성할 수 있습니다. 또는 시스템 내의 협업과 책임에 집중할 수도 있습니다. 또는 현실 세계를 모델링하여 분석 중에 발견된 객체를 설계로 변환할 수 있습니다. 어떤 접근 방식이 가장 좋은지는 항상 논란의 여지가 있습니다.

#### 분석 모델과 설계 모델

많은 객체들이 분석 모델에서 유래하지만, 객체 지향 설계에서는 종종 현실 세계에 대응하는 클래스가 없는 경우가 많습니다. 일부 클래스는 배열 같은 저수준 클래스일 수 있고, 다른 클래스는 매우 높은 수준의 것일 수 있습니다. 예를 들어, **Composite** 패턴은 물리적인 대응 객체 없이 객체들을 일관되게 처리할 수 있는 추상화를 도입합니다.

현실 세계를 엄격하게 모델링하면 오늘날의 현실을 반영하는 시스템이 만들어지지만, 내일의 현실을 반영하지 못할 수 있습니다. 설계 중에 등장하는 추상화는 설계를 유연하게 만드는 데 핵심적인 역할을 합니다. 디자인 패턴은 덜 직관적인 추상화와 이를 캡슐화할 수 있는 객체들을 식별하는 데 도움을 줍니다.

#### 유연하고 재사용 가능한 설계를 위한 객체

예를 들어, 프로세스나 알고리즘을 나타내는 객체는 자연계에서는 발생하지 않지만 유연한 설계에 있어서 중요한 역할을 합니다. **Strategy** 패턴은 교환 가능한 알고리즘 패밀리를 구현하는 방법을 설명합니다. **State** 패턴은 엔티티의 각 상태를 객체로 나타냅니다. 이러한 객체들은 분석이나 초기 설계 단계에서는 잘 발견되지 않지만, 설계를 더 유연하고 재사용 가능하게 만들면서 나중에 발견됩니다.


### 2. 객체의 세분화 결정하기

객체는 크기와 수에 있어서 매우 다양할 수 있습니다. 객체는 하드웨어부터 전체 애플리케이션까지 모든 것을 나타낼 수 있습니다. 그러면 무엇을 객체로 정의할지 어떻게 결정할까요?

디자인 패턴은 이 문제도 다룹니다. 예를 들어:

- **Facade (185)** 패턴은 전체 서브시스템을 객체로 표현하는 방법을 설명합니다. 복잡한 시스템을 하나의 통합된 인터페이스로 캡슐화하여 사용자가 쉽게 접근할 수 있게 합니다.
- **Flyweight (195)** 패턴은 세밀한 수준에서 많은 객체를 효율적으로 지원하는 방법을 설명합니다. 객체의 공유를 통해 메모리 사용을 최소화하면서도 많은 객체를 생성할 수 있도록 합니다.

또한, 다른 디자인 패턴들은 객체를 작은 객체들로 분해하는 구체적인 방법을 제공합니다:

- **Abstract Factory (87)**와 **Builder (97)** 패턴은 객체의 주요 책임이 다른 객체들을 생성하는 것인 경우에 사용됩니다.
- **Visitor (331)**와 **Command (233)** 패턴은 객체나 객체 그룹에 대한 요청을 구현하는 것을 주요 책임으로 합니다. 즉, 해당 객체들은 요청을 처리하는 역할을 수행합니다.

### 3. 객체 인터페이스 정의하기

객체에서 선언된 각 작업은 작업의 이름, 매개변수로 받는 객체들, 그리고 작업의 반환 값을 정의합니다. 이를 작업의 **서명**(signature)이라고 합니다. 객체가 정의한 모든 서명의 집합은 객체의 **인터페이스**(interface)라고 불립니다. 객체의 인터페이스는 해당 객체에 보낼 수 있는 모든 요청을 특성화합니다. 인터페이스에 정의된 서명에 맞는 요청은 모두 해당 객체에 전송할 수 있습니다.

#### 타입과 서브타입

- **타입**은 특정 인터페이스를 나타내는 이름입니다. 예를 들어, "Window"라는 인터페이스에 정의된 모든 요청을 받는 객체는 "Window" 타입을 가집니다.
- 하나의 객체는 여러 타입을 가질 수 있으며, 매우 다른 객체들이 동일한 타입을 공유할 수 있습니다.
- 객체의 일부 인터페이스는 하나의 타입으로 정의될 수 있고, 다른 부분은 다른 타입으로 정의될 수 있습니다.
- 한 타입이 다른 타입의 서브타입이 되려면, 그 타입의 인터페이스가 슈퍼타입의 인터페이스를 포함해야 합니다. 보통 **서브타입**은 **슈퍼타입**의 인터페이스를 **상속**한다고 말합니다.

#### 인터페이스의 중요성

- 객체는 **인터페이스를 통해서만** 인식되고 상호작용됩니다. 객체의 구현에 대해 알 수 없으며, 그 객체에게 작업을 요청할 수 있는 방법도 인터페이스를 통해서만 가능합니다.
- 객체의 인터페이스는 객체의 구현에 대해 아무런 정보를 제공하지 않습니다. 즉, 서로 전혀 다른 구현을 가진 객체들이 동일한 인터페이스를 가질 수 있습니다.

#### 동적 바인딩과 다형성

- 요청을 객체에 보내면, 어떤 작업이 수행될지는 요청과 수신 객체에 따라 달라집니다. 동일한 요청을 지원하는 서로 다른 객체들이 그 요청을 처리하는 방법은 다를 수 있습니다.
- **동적 바인딩**(dynamic binding)은 요청과 객체의 연관이 실행 시간에 결정된다는 것을 의미합니다. 이로 인해 프로그램은 특정 인터페이스를 가진 객체에 대해 요청을 할 수 있으며, 실행 시간에 올바른 객체가 해당 요청을 처리합니다.
- **다형성**(polymorphism)은 동일한 인터페이스를 가진 객체들이 서로 교체 가능함을 의미하며, 객체 지향 시스템에서 핵심 개념입니다. 이를 통해 클라이언트 객체는 다른 객체에 대해 적은 가정을 하고, 객체들 간의 관계를 실행 시간에 동적으로 변경할 수 있습니다.

#### 디자인 패턴과 인터페이스 정의

- 디자인 패턴은 인터페이스를 정의하는 데 도움을 주며, 중요한 요소들과 그 인터페이스를 통해 전달되는 데이터의 종류를 식별합니다. 패턴은 또한 인터페이스에 무엇을 포함하지 말아야 하는지에 대해서도 제시할 수 있습니다.
- 예를 들어, **Memento (283)** 패턴은 객체의 내부 상태를 캡슐화하고 저장하여 나중에 해당 상태로 객체를 복원할 수 있도록 정의합니다. 이 패턴은 Memento 객체가 두 가지 인터페이스를 정의해야 한다고 요구합니다: 하나는 클라이언트가 Memento를 보유하고 복사할 수 있는 제한된 인터페이스이고, 다른 하나는 원래 객체만 사용할 수 있는 특권 인터페이스입니다.

#### 인터페이스 간의 관계

디자인 패턴은 인터페이스 간의 관계를 정의하기도 합니다. 예를 들어:

- **Decorator (175)**와 **Proxy (207)** 패턴은 데코레이터 및 프록시 객체의 인터페이스가 장식된 객체 및 프록시된 객체와 동일해야 한다고 요구합니다.
- **Visitor (331)** 패턴은 방문자가 방문할 수 있는 객체들의 모든 클래스가 **Visitor** 인터페이스에 반영되어야 한다고 명시합니다.

### 4. 객체 구현 정의하기

지금까지 객체를 정의하는 방법에 대해서는 크게 다루지 않았습니다. 객체의 구현은 **클래스**에 의해 정의됩니다. 클래스는 객체의 내부 데이터와 표현 방식을 지정하고, 객체가 수행할 수 있는 작업을 정의합니다.

#### 클래스 정의

- **클래스**는 보통 직사각형 모양으로 나타내며, 클래스 이름은 굵게 표시됩니다. 클래스의 작업은 클래스 이름 아래에 일반 텍스트로 나타납니다. 클래스가 정의하는 데이터는 작업 아래에 나옵니다.
- 반환 타입과 인스턴스 변수 타입은 선택 사항이며, 정적 타입 언어를 전제로 하지 않습니다.

#### 객체 생성 및 인스턴스화

- 객체는 클래스를 **인스턴스화**(instantiation)함으로써 생성됩니다. 인스턴스화된 객체는 해당 클래스의 **인스턴스**라고 합니다. 클래스를 인스턴스화하는 과정은 객체의 내부 데이터(인스턴스 변수로 구성된)를 저장할 공간을 할당하고, 이 데이터에 대해 작업을 연관시킵니다.
- 여러 개의 객체를 만들기 위해 동일한 클래스를 인스턴스화할 수 있습니다.

#### 클래스 관계 및 상속

- 클래스가 다른 클래스를 인스턴스화하는 경우, 이를 나타내기 위해 **대시 화살표**가 사용되며, 화살표는 인스턴스화된 객체의 클래스를 가리킵니다.
- **상속**을 통해 새로운 클래스를 정의할 수 있습니다. 서브클래스는 부모 클래스의 데이터와 작업을 포함하여 정의됩니다. 서브클래스의 객체는 서브클래스와 부모 클래스가 정의한 모든 데이터를 포함하고, 이들이 정의한 모든 작업을 수행할 수 있습니다.
- **상속 관계**는 세로선과 삼각형으로 표시됩니다.

#### 추상 클래스와 구체 클래스

- **추상 클래스**는 주로 자식 클래스들의 공통 인터페이스를 정의하는 데 목적이 있습니다. 추상 클래스는 자식 클래스에서 구현할 작업들을 미리 정의해 두며, 추상 클래스 자체로는 인스턴스를 만들 수 없습니다. 추상 클래스에서 정의되었지만 구현되지 않은 작업은 **추상 작업**(abstract operation)이라고 합니다.
- **구체 클래스**(Concrete Class)는 추상 클래스와 달리 실제 구현이 완료된 클래스를 의미하며, 인스턴스를 만들 수 있습니다.

#### 작업 재정의 및 클래스 세분화

- 서브클래스는 부모 클래스에서 정의된 작업을 **재정의**(override)할 수 있습니다. 작업 재정의는 서브클래스가 요청을 처리하는 방식을 부모 클래스 대신 처리할 수 있게 합니다.
- 클래스 상속은 다른 클래스를 확장하여 클래스를 정의할 수 있게 해주며, 이를 통해 관련된 기능을 가진 객체들 간의 계층을 쉽게 정의할 수 있습니다.

#### 추상 클래스와 구체 클래스의 구분

- 추상 클래스는 기울임꼴로 표시되어 구체 클래스와 구별됩니다. 기울임꼴은 **추상 작업**에도 사용됩니다.
- 다이어그램에 작업 구현을 위한 **유사 코드**(pseudocode)가 포함될 수 있으며, 이 코드가 해당 작업을 구현하는 **대기선 박스**에 연결됩니다.

#### 믹스인 클래스

- **믹스인 클래스**(mixin class)는 다른 클래스에 선택적 인터페이스나 기능을 제공하기 위한 클래스로, 인스턴스화될 목적이 아닙니다. 믹스인 클래스는 **다중 상속**을 요구합니다.

### 5. 클래스와 인터페이스 상속의 차이

객체의 **클래스**와 **타입**의 차이를 이해하는 것이 중요합니다.

- **클래스**는 객체가 어떻게 구현되는지를 정의합니다. 클래스는 객체의 내부 상태와 작업의 구현을 정의합니다.
- **타입**은 객체의 인터페이스를 가리킵니다. 인터페이스는 객체가 응답할 수 있는 요청의 집합을 의미합니다. 객체는 여러 개의 타입을 가질 수 있으며, 서로 다른 클래스의 객체들이 동일한 타입을 가질 수 있습니다.

#### 클래스와 타입의 관계

클래스가 객체의 작업을 정의하므로, 클래스는 객체의 타입도 정의합니다. 객체가 특정 클래스의 인스턴스라고 할 때, 이는 객체가 해당 클래스가 정의한 인터페이스를 지원한다고 암시합니다.

- **C++**나 **Eiffel** 같은 언어에서는 클래스를 사용하여 객체의 타입과 구현을 모두 명시합니다.
- **Smalltalk** 프로그램에서는 변수의 타입을 선언하지 않기 때문에, 컴파일러는 변수에 할당된 객체의 타입이 변수의 타입의 서브타입인지 체크하지 않습니다. 메시지를 보내는 것은 수신자의 클래스가 메시지를 구현하는지 확인하지만, 특정 클래스의 인스턴스인지 확인할 필요는 없습니다.

#### 클래스 상속과 인터페이스 상속

- **클래스 상속**은 객체의 구현을 다른 객체의 구현을 기준으로 정의하는 것입니다. 이는 코드와 표현을 공유하는 메커니즘입니다.
- **인터페이스 상속**(또는 서브타이핑)은 객체가 다른 객체를 대체할 수 있는지를 설명하는 것입니다.

이 두 개념은 많은 언어에서 명확히 구분되지 않기 때문에 혼동할 수 있습니다. 예를 들어, **C++**와 **Eiffel**에서는 상속이 인터페이스 상속과 구현 상속을 동시에 의미합니다. C++에서는 **순수 가상 함수**(pure virtual functions)를 가진 클래스로부터 상속함으로써 인터페이스 상속을 구현합니다. **Smalltalk**에서는 상속이 구현 상속만을 의미합니다.

#### 실용적인 차이점

- **Smalltalk** 프로그래머들은 보통 서브클래스가 서브타입처럼 행동한다고 간주합니다. 
- **C++** 프로그래머들은 **추상 클래스**로 정의된 타입을 통해 객체를 조작합니다.

#### 디자인 패턴과 클래스/인터페이스 상속

많은 디자인 패턴은 클래스 상속과 인터페이스 상속의 구분에 의존합니다. 예를 들어:

- **책임 연쇄 패턴**(Chain of Responsibility)에서는 객체들이 공통 타입을 가져야 하지만, 보통 공통 구현을 공유하지 않습니다.
- **컴포지트 패턴**(Composite)에서는 `Component`가 공통 인터페이스를 정의하지만, `Composite`는 공통 구현을 정의합니다.
- **명령 패턴**(Command), **옵저버 패턴**(Observer), **상태 패턴**(State), **전략 패턴**(Strategy)은 종종 순수 인터페이스인 추상 클래스로 구현됩니다.



### 6. 인터페이스에 맞춰 프로그래밍, 구현에 맞춰 프로그래밍 하지 않기

클래스 상속은 기본적으로 부모 클래스의 기능을 재사용하여 애플리케이션의 기능을 확장하는 메커니즘입니다. 이를 통해 기존 클래스를 기준으로 새로운 종류의 객체를 빠르게 정의할 수 있고, 대부분의 필요한 기능을 상속받아 새로운 구현을 거의 비용 없이 얻을 수 있습니다.

하지만 구현 재사용은 이야기의 절반에 불과합니다. 상속이 객체들의 동일한 인터페이스를 정의하는 데 중요한 역할을 합니다(보통 추상 클래스를 상속받아 구현됨). 왜 그럴까요? 그것은 **다형성**(Polymorphism) 때문입니다.

### 인터페이스 기반 프로그래밍의 장점

상속이 신중하게 사용되면(적절하게 사용되면), 추상 클래스에서 파생된 모든 클래스는 그 인터페이스를 공유하게 됩니다. 즉, 서브클래스는 연산을 추가하거나 오버라이드할 수 있으며, 부모 클래스의 연산을 숨기지 않습니다. 모든 서브클래스는 추상 클래스의 인터페이스에 정의된 요청을 처리할 수 있으므로, 모두 그 추상 클래스의 서브타입이 됩니다.

**인터페이스 기반 프로그래밍**을 통해 다음과 같은 두 가지 주요 이점을 얻을 수 있습니다:
1. **클라이언트**는 객체가 어떤 구체적인 타입인지 알 필요가 없습니다. 객체가 예상하는 인터페이스만 따르기만 하면 됩니다.
2. **클라이언트**는 객체를 구현한 클래스에 대해 알 필요가 없습니다. 클라이언트는 오직 인터페이스를 정의하는 추상 클래스만 알고 있으면 됩니다.

이렇게 구현 의존성을 크게 줄여줍니다. 이로 인해 **재사용 가능한 객체 지향 설계**의 원칙인 다음을 따를 수 있습니다:
- **인터페이스에 맞춰 프로그래밍 하라, 구현에 맞춰 프로그래밍 하지 말라.**

### 설계 원칙

변수를 특정 구체적인 클래스의 인스턴스로 선언하는 대신, **추상 클래스**에서 정의된 인터페이스에만 의존해야 합니다. 이는 이 책에 등장하는 많은 디자인 패턴에서 공통적인 주제입니다.

구체적인 클래스를 인스턴스화해야 하는 경우가 물론 존재하지만(즉, 특정 구현을 지정해야 할 때), 그 과정은 **생성 패턴**(Abstract Factory, Builder, Factory Method, Prototype, Singleton 등)을 통해 추상화됩니다. 이러한 패턴들은 객체 생성 과정을 추상화하여, 인터페이스와 구현 간의 관계를 인스턴스화 시점에 투명하게 연결할 수 있도록 합니다.

**생성 패턴**은 시스템을 구현할 때 인터페이스를 기준으로 작성되도록 도와줍니다.


## 재사용 메커니즘의 활용

대부분 사람들은 객체, 인터페이스, 클래스, 상속과 같은 개념을 이해할 수 있습니다. 하지만 이들을 어떻게 유연하고 재사용 가능한 소프트웨어를 구축하는 데 적용할 것인지는 도전 과제입니다. 디자인 패턴은 이러한 문제를 해결하는 방법을 제공합니다.

### 1 . 상속 vs. 객체 구성

객체 지향 시스템에서 기능을 재사용하는 두 가지 주요 기술은 **클래스 상속**과 **객체 구성**입니다.

- **클래스 상속**: 하나의 클래스를 다른 클래스의 구현을 기준으로 정의하는 방식입니다. 상속을 통한 재사용은 **화이트박스 재사용**이라고도 불리며, "화이트박스"는 부모 클래스의 내부 구현이 자식 클래스에 노출되기 때문입니다.
  
- **객체 구성**: 객체들을 결합하여 더 복잡한 기능을 얻는 방법입니다. 객체 구성은 **블랙박스 재사용**이라고 불리며, 객체의 내부 구현 세부사항은 외부에서 보지 않게 됩니다. 객체는 "블랙박스"처럼 보입니다.

### 상속의 장점과 단점

**장점**:
- 상속은 **컴파일 타임에 정의**되며, 프로그래밍 언어에서 직접 지원되므로 사용하기 쉽습니다.
- 부모 클래스의 기능을 재사용할 수 있고, 서브클래스에서 일부 연산을 재정의할 때 부모 클래스의 연산에도 영향을 미칠 수 있습니다.

**단점**:
- **런타임에서 구현 변경 불가**: 상속은 컴파일 타임에 정의되므로, 런타임에는 상속된 구현을 변경할 수 없습니다.
- **상속이 캡슐화를 깨트림**: 부모 클래스의 내부 구현을 서브클래스가 알게 되므로, 부모 클래스의 구현이 변경되면 서브클래스도 변경해야 합니다. 이는 **구현 의존성**을 만들어내어 재사용을 어렵게 만듭니다. 이를 해결하기 위해서는 **추상 클래스**만 상속하는 것이 좋습니다.

### 객체 구성의 장점

- **런타임에서 동적으로 정의**됩니다. 객체는 다른 객체들의 참조를 통해 구성되며, 각 객체는 서로의 인터페이스를 존중해야 합니다. 이는 **캡슐화를 유지**하는데 중요한 역할을 합니다.
- 객체는 인터페이스를 통해서만 접근하므로, 객체의 구현을 변경해도 다른 객체들에 영향을 미치지 않으며, **구현 의존성**이 적습니다.
- 객체 구성은 클래스를 작게 유지하게 하고, 시스템의 행동은 객체 간의 관계에 따라 정의됩니다. 반면, 클래스 상속에 의한 설계는 더 커지고 관리하기 어려운 클래스를 만들 수 있습니다.

### 객체 지향 설계 원칙

**객체 구성**을 **클래스 상속**보다 우선시하라. 이는 시스템을 설계할 때 각 클래스가 하나의 작업에 집중하고, 시스템의 동작이 클래스보다 객체 간의 관계에 의존하게 만듭니다.

### 결론

이상적으로는 새 컴포넌트를 만들지 않고, **기존 컴포넌트**들을 객체 구성을 통해 조합하여 필요한 모든 기능을 얻을 수 있어야 합니다. 하지만 실제로는 사용할 수 있는 컴포넌트 세트가 충분히 풍부하지 않아서 상속을 통해 새 컴포넌트를 만드는 것이 더 쉬울 때도 많습니다. 따라서 상속과 객체 구성은 **상호 보완적인 관계**에 있습니다.

**디자이너들이 상속을 과도하게 사용**하는 경향이 있지만, **객체 구성**에 의존하는 설계가 더 재사용 가능하고 단순한 경우가 많습니다. 객체 구성은 디자인 패턴에서 자주 사용되는 방식입니다.

### 2. 위임 (Delegation)

**위임(Delegation)**은 객체 구성(Object Composition)을 상속(Inheritance)만큼 강력하게 재사용할 수 있는 방법입니다. 위임에서는 두 개의 객체가 요청을 처리하는 데 관여합니다: 하나의 객체는 요청을 받고, 그 요청을 다른 객체에게 위임합니다. 이는 상속에서 자식 클래스가 부모 클래스에게 요청을 위임하는 것과 유사합니다. 하지만 상속에서는 상속된 연산이 `this`(C++) 또는 `self`(Smalltalk)를 통해 수신 객체를 참조할 수 있습니다. 위임에서는 수신 객체가 자신을 위임 객체에 전달하여, 위임된 연산이 수신 객체를 참조하도록 합니다.

### 위임 예시

예를 들어, **Window** 클래스를 **Rectangle**의 서브클래스로 만드는 대신, **Window** 클래스는 **Rectangle** 인스턴스를 유지하고, 직사각형 관련 행동을 그 객체에 위임할 수 있습니다. 즉, Window는 Rectangle을 "가진다"는 개념으로, 이제 Window는 명시적으로 요청을 Rectangle 인스턴스로 전달해야 합니다. 

다음은 **Window** 클래스가 **Rectangle** 인스턴스에게 **Area** 연산을 위임하는 다이어그램을 설명한 예시입니다.

### 위임의 장점

- **런타임에서 동적인 객체 구성**이 가능해지고, 객체가 어떻게 구성되는지 변경하기 쉬워집니다. 예를 들어, Window는 실행 중에 **Rectangle**을 **Circle** 인스턴스로 교체하여 원 모양의 윈도우로 바꿀 수 있습니다. 
- 객체는 인터페이스를 통해 상호작용하므로, 런타임에서 쉽게 교체 가능합니다.

### 위임의 단점

- **동적이고 고도로 매개변수화된 소프트웨어는 이해하기 어렵다**는 단점이 있습니다. 
- 또한 **런타임 비효율성**도 있지만, 이해의 어려움이 장기적으로 더 중요한 문제입니다.
- 위임은 소프트웨어 설계를 단순하게 만드는 경우에만 유용하며, 복잡성을 더하는 경우에는 적합하지 않습니다.

### 위임을 사용하는 디자인 패턴

- **State(305)**: 객체가 현재 상태를 나타내는 **State 객체**에게 요청을 위임합니다.
- **Strategy(315)**: 특정 요청을 수행하는 **Strategy 객체**에 요청을 위임합니다. 객체는 하나의 상태만 가질 수 있지만, 여러 전략을 가질 수 있습니다.
- **Visitor(331)**: 객체 구조의 각 요소에 수행할 작업을 **Visitor 객체**에게 위임합니다.

### 덜 사용되는 위임을 사용하는 패턴들

- **Mediator(273)**: 객체 간의 통신을 중재하는 객체를 도입하며, 때때로 **Mediator** 객체가 다른 객체에게 요청을 전달하기만 하기도 하고, **위임**을 사용할 때도 있습니다.
- **Chain of Responsibility(223)**: 요청을 하나의 객체에서 다른 객체로 전달하는 패턴으로, 때때로 요청이 원래 객체를 참조하는 경우 위임을 사용합니다.
- **Bridge(151)**: 추상화와 구현을 분리하는 패턴으로, 추상화와 구현이 밀접하게 매칭되면 추상화가 구현에게 연산을 위임할 수 있습니다.

### 결론

위임은 객체 구성의 극단적인 예로, **상속**을 **객체 구성**으로 대체할 수 있는 메커니즘을 보여줍니다. 이를 통해 재사용 가능한 코드를 보다 유연하고 효과적으로 구성할 수 있습니다.

### 3. 상속 대 매개변수화된 타입 (Parameterized Types)

**매개변수화된 타입**(Parameterized Types)은 객체 지향적이지 않은 기능 재사용 기법으로, **제네릭**(Ada, Eiffel) 또는 **템플릿**(C++)이라고도 불립니다. 이 기법은 타입을 정의할 때 사용하는 다른 타입을 모두 명시하지 않고, 사용 시점에 필요한 타입을 매개변수로 전달하는 방식입니다. 예를 들어, **List** 클래스는 그 안에 포함되는 요소의 타입을 매개변수로 받아들일 수 있습니다. 정수 리스트를 선언하려면 `integer` 타입을 매개변수로 전달하고, 문자열 리스트를 선언하려면 `String` 타입을 매개변수로 전달합니다. 언어 구현은 각 타입에 대해 맞춤형 **List** 클래스 템플릿을 생성합니다.

### 매개변수화된 타입의 특징

- 매개변수화된 타입은 객체 지향 시스템에서 행동을 구성하는 세 가지 방법 중 하나로, 상속(Inheritance)과 객체 구성(Object Composition) 외에 세 번째 방법을 제공합니다. 예를 들어, 정렬 루틴을 매개변수화하려면, **비교 연산**을 처리하는 방법을 다음과 같이 구현할 수 있습니다:
  1. 비교 연산을 **서브클래스**에서 구현하는 방법 (Template Method 패턴)
  2. 비교 연산을 **객체**가 담당하도록 하는 방법 (Strategy 패턴)
  3. **C++ 템플릿** 또는 **Ada 제네릭**을 사용하여 비교 함수를 매개변수로 지정하는 방법

### 각 기법의 차이점

- **객체 구성**: 런타임에서 구성된 행동을 변경할 수 있으나, 간접적인 방식이 필요하고 효율성이 떨어질 수 있습니다.
- **상속**: 기본 구현을 제공하고 서브클래스가 이를 오버라이드할 수 있습니다. 하지만 런타임에서 변경이 불가능합니다.
- **매개변수화된 타입**: 클래스가 사용할 타입을 변경할 수 있지만, 런타임에서 변경할 수는 없습니다.

### 결론

어떤 접근 방식이 최적인지는 설계와 구현의 제약에 따라 달라집니다. 이 책의 디자인 패턴에서는 매개변수화된 타입을 사용하지 않지만, C++ 구현에서는 특정 패턴을 사용자 정의할 때 가끔 사용됩니다. **Smalltalk**와 같은 언어에서는 컴파일 타임 타입 검사가 없기 때문에 매개변수화된 타입이 필요하지 않습니다.

## 4. 런타임과 컴파일 타임 구조의 관계

객체 지향 프로그램의 런타임 구조는 코드 구조와 종종 거의 관련이 없습니다. 코드 구조는 컴파일 타임에 고정되며, 이는 고정된 상속 관계의 클래스로 구성됩니다. 반면 프로그램의 런타임 구조는 빠르게 변화하는 객체들 간의 통신 네트워크로 구성됩니다. 사실, 두 구조는 대부분 독립적입니다. 이를 이해하는 것은 살아있는 생태계의 역동성을 식물과 동물의 정적인 분류 체계로 이해하려는 것과 유사합니다.

### 집합(Aggregation)과 인식(Acquaintance)의 차이

- **집합(Aggregation)**: 한 객체가 다른 객체를 소유하거나 책임진다는 의미입니다. 일반적으로 하나의 객체가 다른 객체를 가지거나 그 객체의 일부라고 표현합니다. 집합 관계에서는 집합 객체와 그 소유 객체의 수명이 동일합니다.
- **인식(Acquaintance)**: 한 객체가 다른 객체를 단순히 알고 있다는 의미입니다. 인식은 객체들이 서로 작업을 요청할 수 있지만, 서로를 책임지지 않는 관계입니다. 인식은 집합보다 약한 관계로, 객체 간의 결합도가 느슨합니다.

### 컴파일 타임과 런타임의 차이

- **컴파일 타임**: 코드 구조는 고정되어 있고, 주로 클래스와 상속 관계로 구성됩니다.
- **런타임**: 런타임 구조는 빠르게 변화하는 객체 간의 관계로 구성되며, 이는 코드로부터 쉽게 드러나지 않습니다.

### 집합과 인식의 구현

- **Smalltalk**: 모든 변수는 다른 객체에 대한 참조를 의미하며, 집합과 인식 사이의 구분이 언어 차원에서 없습니다.
- **C++**: 집합은 멤버 변수를 실제 인스턴스로 정의하여 구현할 수 있지만, 대부분 포인터나 참조를 사용하여 구현됩니다. 인식도 포인터와 참조로 구현됩니다.

### 런타임 구조 설계의 중요성

집합과 인식은 명시적인 언어적 기법보다는 의도에 의해 결정됩니다. 컴파일 타임 구조에서 이 차이를 명확히 보기는 어렵지만, 이는 중요합니다. 집합 관계는 적고 더 영구적인 경향이 있는 반면, 인식 관계는 더 자주 생성되고 소멸하며, 때로는 작업이 진행되는 동안만 존재할 수 있습니다. 인식 관계는 더 동적이며, 소스 코드에서 이해하기 더 어렵습니다.

### 디자인 패턴과 런타임 구조

런타임 구조는 코드에서 드러나지 않으며, 시스템의 런타임 구조는 언어보다 설계자에 의해 더 많이 결정됩니다. 객체 간의 관계와 타입은 매우 신중하게 설계해야 하며, 이는 시스템의 런타임 구조를 결정짓습니다. 많은 디자인 패턴(특히 객체 범위와 관련된 패턴)은 컴파일 타임과 런타임 구조의 차이를 명확하게 캡처합니다.

- **Composite (163)**, **Decorator (175)**: 복잡한 런타임 구조를 구축하는 데 유용한 패턴
- **Observer (293)**: 패턴을 이해하지 않으면 런타임 구조를 파악하기 어려움
- **Chain of Responsibility (223)**: 상속 관계로는 드러나지 않는 커뮤니케이션 패턴을 생성

대체로 런타임 구조는 코드에서 명확히 드러나지 않으며, 패턴을 이해할 때 그 구조를 알 수 있습니다.

### 5. 변경을 고려한 설계 (Designing for Change)

시스템을 재사용 가능하고 확장 가능하게 만들기 위해서는 새로운 요구 사항과 기존 요구 사항의 변경을 예측하고, 시스템을 그에 맞게 설계하는 것이 중요합니다. 변화를 고려하지 않은 설계는 향후 대규모 리디자인을 초래할 위험이 있습니다. 이러한 변화는 클래스 재정의, 클라이언트 수정, 재테스트 등을 포함할 수 있으며, 예기치 않은 변경은 비용이 많이 듭니다.

디자인 패턴은 시스템이 특정 방식으로 변할 수 있도록 보장함으로써 이러한 문제를 피하는 데 도움을 줍니다. 각 디자인 패턴은 시스템 구조의 일부를 다른 부분과 독립적으로 변할 수 있도록 하여, 특정 종류의 변화에 더 강한 시스템을 만들 수 있게 합니다.

### 일반적인 리디자인 원인과 이를 해결하는 디자인 패턴

1. **명시적으로 클래스를 지정하여 객체 생성**
   - 클래스 이름을 직접 지정하여 객체를 생성하면 특정 구현에 의존하게 되므로 미래의 변경이 복잡해질 수 있습니다.
   - **디자인 패턴**: Abstract Factory (87), Factory Method (107), Prototype (117)

2. **특정 연산에 의존**
   - 특정 연산을 지정하면 한 가지 방식으로 요청을 처리하는 데 고정되며, 이를 피하려면 하드코딩된 요청을 피해야 합니다.
   - **디자인 패턴**: Chain of Responsibility (223), Command (233)

3. **하드웨어 및 소프트웨어 플랫폼 의존**
   - 운영 체제나 API가 플랫폼마다 다르므로 특정 플랫폼에 의존하는 소프트웨어는 다른 플랫폼으로 포팅하기 어려워질 수 있습니다.
   - **디자인 패턴**: Abstract Factory (87), Bridge (151)

4. **객체 표현이나 구현에 의존**
   - 객체가 어떻게 표현, 저장, 위치 또는 구현되는지 알게 되면 객체가 변경될 때마다 클라이언트도 수정해야 할 수 있습니다. 이를 숨기면 변경이 확산되는 것을 방지할 수 있습니다.
   - **디자인 패턴**: Abstract Factory (87), Bridge (151), Memento (283), Proxy (207)

5. **알고리즘 의존**
   - 알고리즘은 개발 중에 확장되거나 최적화되어 교체될 수 있습니다. 알고리즘에 의존하는 객체는 알고리즘이 변경될 때마다 수정이 필요합니다. 따라서 변경될 가능성이 있는 알고리즘은 격리하는 것이 중요합니다.
   - **디자인 패턴**: Builder (97), Iterator (257), Strategy (315), Template Method (325), Visitor (331)

6. **강한 결합**
   - 클래스가 강하게 결합되어 있으면 독립적으로 재사용하기 어렵고, 한 클래스를 변경하려면 다른 많은 클래스를 이해하고 변경해야 할 수 있습니다. 느슨한 결합은 시스템을 더 쉽게 학습하고, 포팅하고, 수정하고 확장할 수 있게 합니다.
   - **디자인 패턴**: Abstract Factory (87), Bridge (151), Chain of Responsibility (223), Command (233), Facade (185), Mediator (273), Observer (293)

7. **서브클래싱을 통한 기능 확장**
   - 객체를 서브클래싱하여 기능을 확장하는 것은 어렵고, 새로운 클래스가 추가될 때마다 구현 오버헤드가 발생할 수 있습니다. 서브클래싱은 또한 많은 새로운 서브클래스를 필요로 할 수 있습니다. 객체 구성 및 위임을 사용하면 더 유연한 방식으로 기능을 결합할 수 있습니다.
   - **디자인 패턴**: Bridge (151), Chain of Responsibility (223), Composite (163), Decorator (175), Observer (293), Strategy (315)

8. **수정이 어려운 클래스**
   - 때로는 클래스를 수정해야 할 때 해당 클래스를 수정하기 어려운 경우가 있습니다. 예를 들어, 상용 클래스 라이브러리에서 소스 코드를 얻을 수 없거나, 수정이 기존 서브클래스를 모두 수정해야 할 수 있습니다. 디자인 패턴은 이런 경우에도 클래스를 수정할 수 있는 방법을 제공합니다.
   - **디자인 패턴**: Adapter (139), Decorator (175), Visitor (331)

### 결론

디자인 패턴은 시스템에 유연성을 제공하여 소프트웨어의 발전 과정에서 발생할 수 있는 다양한 변화에 잘 대응할 수 있도록 합니다. 어떤 종류의 소프트웨어를 개발하느냐에 따라 이러한 유연성의 중요성은 달라지지만, 패턴을 사용하면 구조적 변화를 보다 효율적으로 관리할 수 있습니다.

### 6. 애플리케이션 프로그램 (Application Programs)

애플리케이션 프로그램(예: 문서 편집기나 스프레드시트)을 구축하는 경우, 내부 재사용성, 유지보수성, 확장성이 중요한 우선 사항입니다. 내부 재사용성은 필요한 것만 설계하고 구현하도록 도와줍니다. 디자인 패턴은 종속성을 줄여 내부 재사용성을 증가시킬 수 있습니다. 느슨한 결합은 하나의 객체가 여러 다른 객체와 협력할 가능성을 높입니다.

#### 주요 개념:
1. **내부 재사용성**: 특정 작업에 대한 의존성을 없애면 동일한 작업을 다른 컨텍스트에서 재사용하기가 쉬워집니다. 알고리즘과 표현에 대한 의존성도 제거하면 재사용성이 더욱 향상됩니다.
2. **유지보수성**: 디자인 패턴을 사용하면 플랫폼 의존성을 제한하고 시스템을 레이어로 분리할 수 있어 유지보수성을 향상시킵니다.
3. **확장성**: 클래스 계층을 확장하는 방법과 객체 구성을 활용하는 방법을 제시하여 시스템의 확장성을 향상시킵니다. 결합도를 줄이면 클래스를 독립적으로 확장하기가 더 쉬워집니다.

### 7. 툴킷 (Toolkits)

애플리케이션은 종종 하나 이상의 미리 정의된 클래스 라이브러리인 툴킷을 통합합니다. 툴킷은 유용하고 범용적인 기능을 제공하는 관련된 재사용 가능한 클래스들의 집합입니다. 예를 들어, 리스트, 연관 테이블, 스택 등을 위한 컬렉션 클래스 세트가 툴킷의 예입니다. C++의 I/O 스트림 라이브러리도 툴킷의 예시입니다. 

#### 툴킷의 특징:
1. **기능 제공**: 툴킷은 애플리케이션에 특정한 디자인을 강요하지 않고, 애플리케이션이 작업을 수행하는 데 도움이 되는 기능을 제공합니다.
2. **코드 재사용 강조**: 툴킷은 일반적으로 코드 재사용을 강조하며, 이는 서브루틴 라이브러리와 유사한 객체 지향적인 접근 방식입니다.
3. **디자인의 어려움**: 툴킷은 여러 애플리케이션에서 유용하게 작동해야 하므로 애플리케이션 디자인보다 더 어려운 경우가 많습니다. 툴킷 작성자는 애플리케이션의 특수한 요구 사항을 알지 못하기 때문에, 툴킷의 유연성을 제한할 수 있는 가정이나 의존성을 피하는 것이 매우 중요합니다.

### 8. 프레임워크 (Frameworks)

프레임워크는 특정 소프트웨어 클래스에 대한 재사용 가능한 디자인을 제공하는 상호 협력하는 클래스 집합입니다. 예를 들어, 다양한 도메인(예: 예술적 드로잉, 음악 작곡, 기계 CAD 등)을 위한 그래픽 편집기를 구축하는 프레임워크나, 다른 프로그래밍 언어와 타겟 머신을 위한 컴파일러를 구축하는 프레임워크 등이 있습니다. 프레임워크는 추상 클래스의 애플리케이션-specific 서브클래스를 작성하여 특정 애플리케이션에 맞게 맞춤화됩니다.

#### 프레임워크의 특징:
1. **애플리케이션 아키텍처 정의**: 프레임워크는 애플리케이션의 전반적인 구조, 클래스와 객체의 분할, 책임, 클래스 간 협력, 제어 흐름 등을 정의합니다. 이를 통해 애플리케이션 설계자가 애플리케이션의 세부 사항에 집중할 수 있습니다.
2. **디자인 재사용 강조**: 프레임워크는 코드 재사용보다 디자인 재사용을 강조합니다. 프레임워크는 미리 정의된 설계를 통해 애플리케이션을 빠르게 구축할 수 있도록 하며, 애플리케이션 간의 유사성을 제공합니다.
3. **제어의 역전 (Inversion of Control)**: 툴킷과 달리 프레임워크는 제어 흐름을 반대로 바꿔 놓습니다. 툴킷을 사용할 때는 애플리케이션 본문을 작성하고, 필요한 코드만 호출합니다. 반면, 프레임워크를 사용할 때는 애플리케이션 본문이 미리 정의되어 있고, 작성자는 프레임워크가 호출하는 코드를 작성해야 합니다.
4. **유연성과 확장성**: 프레임워크는 유연하고 확장 가능하도록 설계되어야 하며, 프레임워크가 변경되면 이를 사용하는 애플리케이션도 함께 발전해야 합니다. 이를 위해 느슨한 결합이 중요합니다.
5. **설계 패턴 사용**: 성숙한 프레임워크는 여러 설계 패턴을 포함하고 있으며, 이를 통해 다양한 애플리케이션에 맞게 아키텍처를 조정합니다. 설계 패턴을 문서화하면 프레임워크의 구조를 빠르게 이해할 수 있습니다.

#### 프레임워크와 설계 패턴의 차이점:
1. **추상화 수준**: 설계 패턴은 프레임워크보다 더 추상적이며, 코드로 구현될 수 있는 것은 예시뿐입니다. 반면, 프레임워크는 실제 코드로 구현되어 실행 및 재사용이 가능합니다.
2. **구조적 규모**: 프레임워크는 여러 설계 패턴을 포함할 수 있지만, 설계 패턴은 그 자체로 프레임워크처럼 큰 구조를 이루지 않습니다.
3. **특화된 목적**: 프레임워크는 항상 특정 애플리케이션 도메인에 맞춰 설계됩니다. 반면, 설계 패턴은 다양한 애플리케이션에서 사용할 수 있는 보다 일반적인 해결책입니다.

프레임워크는 객체 지향 시스템에서 가장 높은 수준의 재사용을 달성하는 방식이며, 대형 애플리케이션은 여러 프레임워크로 구성되어 상호작용합니다. 대부분의 디자인 및 코드가 사용 중인 프레임워크에서 유래하거나 영향을 받습니다.


## 1.7 디자인 패턴 선택 방법

디자인 패턴이 20개 이상 있는 이 카탈로그에서 특정 디자인 문제를 해결하는 패턴을 찾는 것은 어려울 수 있습니다. 특히 카탈로그가 새롭고 익숙하지 않다면 더욱 그렇습니다. 아래는 적절한 디자인 패턴을 선택하는 다양한 접근 방법입니다:

1. **디자인 패턴이 문제를 해결하는 방식 고려**  
   - 섹션 1.6에서는 디자인 패턴이 객체를 찾고, 객체의 세분화 수준을 결정하고, 객체 인터페이스를 명시하는 등 여러 방법으로 디자인 문제를 해결하는 방식을 설명합니다. 이 내용을 참고하여 문제에 맞는 패턴을 찾는 데 도움이 될 수 있습니다.

2. **의도(Intent) 섹션 읽기**  
   - 섹션 1.4 (페이지 8)에서는 각 패턴의 의도 섹션을 나열합니다. 각 패턴의 의도를 읽고 문제와 관련된 패턴을 찾습니다. 또한, 테이블 1.1 (페이지 10)에서 제공하는 분류 체계를 활용하여 검색 범위를 좁힐 수 있습니다.

3. **패턴 간의 상호 관계 연구**  
   - 그림 1.1 (페이지 12)은 디자인 패턴 간의 관계를 시각적으로 보여줍니다. 이 관계를 연구하여 적합한 패턴이나 패턴 그룹으로 안내받을 수 있습니다.

4. **유사 목적의 패턴 연구**  
   - 카탈로그 (페이지 79)에는 창조적 패턴, 구조적 패턴, 행동적 패턴을 다룬 세 개의 장이 있습니다. 각 장에서는 패턴에 대한 소개를 제공하고, 각 패턴의 유사점과 차이점을 비교하고 대조하는 섹션이 있습니다. 이를 통해 유사한 목적을 가진 패턴의 차이점을 이해할 수 있습니다.

5. **재설계의 원인 살펴보기**  
   - 페이지 24에서 시작하는 재설계의 원인을 살펴보고, 문제에 해당하는 원인이 있는지 확인합니다. 그런 다음, 재설계를 피할 수 있도록 도와주는 패턴을 찾아봅니다.

6. **디자인에서 변할 수 있는 요소 고려**  
   - 이 접근 방법은 재설계의 원인에 집중하는 것과 반대로, 디자인에서 변할 수 있는 요소가 무엇인지 고려하는 것입니다. 변경이 필요한 요소를 캡슐화하는 패턴을 찾는 데 초점을 맞추며, 디자인에서 변할 수 있는 요소를 독립적으로 바꿀 수 있게 해주는 패턴이 많습니다. 테이블 1.2에서는 디자인 패턴이 독립적으로 변경 가능한 디자인 측면을 나열하여 재설계 없이 변화를 가능하게 합니다.


## 1.8 디자인 패턴 사용 방법

디자인 패턴을 선택한 후, 이를 효과적으로 적용하는 단계별 접근 방식은 다음과 같습니다:

1. **패턴을 한 번 전체적으로 읽어보기**  
   - 패턴의 개요를 이해하고, **적용 가능성**(Applicability)과 **결과**(Consequences) 섹션을 주의 깊게 읽어 문제에 적합한 패턴인지 확인합니다.

2. **구조, 참여자, 협업 섹션 공부하기**  
   - 패턴에서 사용되는 클래스와 객체들, 그리고 그들 간의 관계를 이해합니다.

3. **샘플 코드 섹션 확인하기**  
   - 패턴을 실제 코드로 구현한 예제를 살펴보고, 이를 통해 패턴 구현 방법을 배웁니다.

4. **패턴 참여자들에게 의미 있는 이름 부여하기**  
   - 패턴에서 사용하는 참여자들의 이름은 보통 추상적이므로, 애플리케이션의 맥락에 맞게 구체적인 이름을 부여합니다. 예를 들어, 전략 패턴을 텍스트 조합 알고리즘에 사용한다면 `SimpleLayoutStrategy`나 `TeXLayoutStrategy`와 같은 이름을 사용할 수 있습니다.

5. **클래스 정의하기**  
   - 클래스의 인터페이스를 선언하고, 상속 관계를 설정하며, 데이터와 객체 참조를 나타내는 인스턴스 변수를 정의합니다. 또한, 패턴이 애플리케이션에서 영향을 미칠 기존 클래스들을 찾아 적절히 수정합니다.

6. **애플리케이션에 맞는 연산 이름 정의하기**  
   - 연산 이름은 애플리케이션에 따라 달라지므로, 각 연산의 책임과 협업을 바탕으로 이름을 정합니다. 또한, 명명 규칙을 일관되게 유지합니다. 예를 들어, 팩토리 메서드를 나타내기 위해 "Create-" 접두사를 사용할 수 있습니다.

7. **패턴에서 정의된 책임과 협업을 구현하기**  
   - 각 연산을 구현하여 패턴에서 요구하는 책임과 협업을 수행합니다. **구현 섹션**은 이를 구현하는 데 도움이 되는 힌트를 제공합니다. 또한, **샘플 코드**를 참고하여 구현을 진행할 수 있습니다.

이 가이드는 디자인 패턴을 적용하는 시작점을 제공하는 것입니다. 시간이 지나면서 자신만의 패턴 적용 방식을 개발하게 될 것입니다.

#### 디자인 패턴 사용 시 피해야 할 점

디자인 패턴을 남용해서는 안 됩니다. 패턴은 종종 **유연성**과 **변동성**을 제공하지만, 이를 위해 추가적인 간접적인 계층을 도입하는 경우가 많습니다. 이러한 추가적인 계층은 디자인을 복잡하게 만들거나 성능에 비용을 발생시킬 수 있습니다. 패턴은 **필요한 유연성**이 있을 때만 적용해야 하며, 패턴의 **결과 섹션**을 통해 장단점을 잘 평가하는 것이 중요합니다.

